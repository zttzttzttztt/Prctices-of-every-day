/*1.基本原理
  例：nums=[0,5,2,3,6,8,9,1]一共8个数
  (1)我们首先令增量gap=n/2=4。
  这样从a1开始，a1和a5成为一组，a2和a6成为一组，a3和a7成为一组，a4和a8成为一组，对于这四组，
  每组组内进行插入排序，这样一次排序之后就会变成nums=[0,5,2,1,6,8,9,3]。
  (2)我们令gap=gap/2=2。
  这样从a1开始，a1、a3、a5、a7成为一组，a2、a4、a6、a8成为一组，每组组内进行插入排序，这样
  二次排序之后就会变成nums=[0,1,2,3,6,5,9,8]。
  (3)我们令gap=gap/2=1。
  这样从a1开始，a1、a2、a3、a4、a5、a6、a7、a8成为一组，组内进行插入排序，这样三次排序之后
  就会变成nums=[0,1,2,3,5,6,8,9]。
  这就是希尔排序的过程，首先确定一个增量gap，从a1开始把a1、a1+gap、a1+2*gap等数包含到一个
  组里，对组内的数进行插入排序；然后不停缩小这个增量序列，直到gap=1时(必须要有)变为全体进行插入排序。
  希尔排序gap的选择其实是个比较难的数学问题。上面例子中gap的选择是希尔本人提倡的方式，即每次都对半，
  然而这样的选择其实是效率很低的，有时甚至会使复杂度降到O(N2)。
  有一种广泛接受的gap选择公式是gap=gap*3+1。因为最后一次gap一定等于1，所以我们可以逆向反推前面的gap的值应该
  为1,4,13,40,121,364,1093……，对于一个数组，只需要从小于数组个数的最大值开始设定gap就可以了。比如一个数组有
  700个数，那我们就设定初始gap=364,然后下一次排序gap=121，再下一次gap=40，这样一直到gap=1。
  */


void ShellSort(int *nums,int n)//希尔排序
{
    int gap=1;
    while(gap*3+1<n)
        gap=gap*3+1;
    while(gap>0)
    {
        for(int i=0;i<gap;i++)//i代表组数，组数其实就是gap
        {
            //下面是插入排序
            for(int j=i+gap;j<n;j=j+gap)//j代表循环从组内第2个数开始，每个数间隔gap
            {
                for(int k=j;k>=gap;k=k-gap)//k代表组内每个数都向前比较,直到找到合适位置
                {
                    if(nums[k]<nums[k-gap])//如果选取数比当前数小则交换
                    {
                        int temp=nums[k-gap];
                        nums[k-gap]=nums[k];
                        nums[k]=temp;
                    }
                    else
                        break;
                }
            }
        }
        gap=(gap-1)/3;
    }
}
